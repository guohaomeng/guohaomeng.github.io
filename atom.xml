<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://guohaomeng.github.io</id>
    <title>meng的博客</title>
    <updated>2019-11-07T13:45:50.540Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://guohaomeng.github.io"/>
    <link rel="self" href="https://guohaomeng.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://guohaomeng.github.io/images/avatar.png</logo>
    <icon>https://guohaomeng.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, meng的博客</rights>
    <entry>
        <title type="html"><![CDATA[git简易教程（二）]]></title>
        <id>https://guohaomeng.github.io/post/git-jian-yi-jiao-cheng-er</id>
        <link href="https://guohaomeng.github.io/post/git-jian-yi-jiao-cheng-er">
        </link>
        <updated>2019-11-06T15:04:49.000Z</updated>
        <summary type="html"><![CDATA[<p>git的初始配置及基本用法</p>
]]></summary>
        <content type="html"><![CDATA[<p>git的初始配置及基本用法</p>
<!-- more -->
<h2 id="一初次运行git前的配置">一·初次运行git前的配置</h2>
<ol>
<li>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：</li>
</ol>
<pre><code>git config --global user.name &quot;你的用户名&quot;
git config --global user.email 你的邮箱@163.com
</code></pre>
<p>第二行**处填邮箱</p>
<h2 id="二获取git仓库">二·获取git仓库</h2>
<p>两种获取Git项目仓库的方法： 一是在现有项目或目录下导入所有文件到Git中； 二是从一个服务器克隆一个现有的Git仓库。</p>
<ol>
<li>在现有目录中初始化仓库，进入该目录，右键git bash here</li>
</ol>
<pre><code>git init
</code></pre>
<p>该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。<br>
2. 克隆远程仓库，示例，克隆一下咱们网络信息协会的teamwork测试仓库</p>
<pre><code>git clone https://github.com/wlxxxh/teamwork.git
</code></pre>
<p>该命令执行后会在当前目录下创建一个名为 “teamwork” 的目录，并在在这个目录下初始化一个.git文件夹，从远程仓库拉取所有的数据放在改文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 teamwork 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。</p>
<p>克隆地址可以从这里复制<br>
<img src="https://guohaomeng.github.io/post-images/1573053650627.jpg" alt=""></p>
<h2 id="三git基本操作">三·git基本操作</h2>
<p>上面，我们已经克隆了teamwork仓库到本地了，现在给大家演示一下基本操作，即修改仓库的文件，再将其提交到远程仓库</p>
<pre><code>$ ls    //列出当前目录下的文件
001.txt  README.md
</code></pre>
<p>比如我们将001.txt内加入一行新的文本 test2<br>
回到git命令行</p>
<pre><code>$ git status    //检查仓库状态
On branch master
Your branch is up to date with 'origin/master'.

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)
        modified:   001.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>此时会提醒你001.txt文件已经被修改，下面我们将这个修改添加到git暂存区</p>
<pre><code>$ git add 001.txt   //add命令，将修改提交到暂存区
 warning: LF will be replaced by CRLF in 001.txt.
The file will have its original line endings in your working directory
</code></pre>
<p>修改后的文件被放到到暂存区后，我们就可以正式提交它了，运行</p>
<pre><code>$ git commit -m &quot;第二次提交测试&quot; //commit命令，将暂存区文件正式添加到仓库中去，-m 后面跟提交信息，用双引号围起来，提交信息是一定要写的
    [master 4a6fafe] 第二次提交测试
1 file changed, 1 insertion(+)
</code></pre>
<p>每次更改都要先执行add再执行commit</p>
<pre><code>git add .   //将当前目录下所有更改都提交到暂存区
git commit -a -m &quot;提交信息&quot;     //其实如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。
</code></pre>
<p>如果此时我们再检查一下仓库状态</p>
<pre><code>$ git status
On branch master
Your branch is ahead of 'origin/master' by 1 commit.
  (use &quot;git push&quot; to publish your local commits)

nothing to commit, working tree clean
</code></pre>
<p>他就会提示现在工作目录是干净的，无需提交了<br>
下面我们将我们所做的更改推送到远程仓库里去，运行</p>
<pre><code>$ git push  //push命令，将改动后的代码推送到远程仓库里
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 8 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 309 bytes | 309.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/wlxxxh/teamwork.git
   d80cde2..4a6fafe  master -&gt; master
</code></pre>
<p>现在我们去GitHub远程仓库去看一下，看这个仓库是否已经被更改了<br>
<img src="https://guohaomeng.github.io/post-images/1573133685551.jpg" alt=""><br>
果然，成功了，第二行出现了test2<br>
好了，最基本的git操作就是这样了，关于git的更多用法，大家可以参考这两处哦</p>
<ol>
<li><a href="https://blog.csdn.net/daily886/article/details/80140720">https://blog.csdn.net/daily886/article/details/80140720</a></li>
<li><a href="https://www.runoob.com/git/git-basic-operations.html">https://www.runoob.com/git/git-basic-operations.html</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git简易教程（一）]]></title>
        <id>https://guohaomeng.github.io/post/git-jian-yi-jiao-cheng</id>
        <link href="https://guohaomeng.github.io/post/git-jian-yi-jiao-cheng">
        </link>
        <updated>2019-11-06T09:54:50.000Z</updated>
        <summary type="html"><![CDATA[<p>包括GitHub的注册以及git的安装</p>
]]></summary>
        <content type="html"><![CDATA[<p>包括GitHub的注册以及git的安装</p>
<!-- more -->
<h2 id="一github的注册">一·GitHub的注册</h2>
<p>首先，进入<a href="https://github.com/">GitHub的官网</a></p>
<figure data-type="image" tabindex="1"><img src="https://guohaomeng.github.io/post-images/1573034456678.jpg" alt=""></figure>
<p>直接填写用户名、邮箱、密码就行了</p>
<p>期间要验证一下邮箱，邮箱里点击后跳转登陆就行了<br>
<img src="https://guohaomeng.github.io/post-images/1573036068386.jpg" alt=""><br>
恭喜！现在注册完了，你现在已经正式成为GitHub的一员了。<br>
<img src="https://guohaomeng.github.io/post-images/1573036017274.jpg" alt=""></p>
<h2 id="二git的安装">二·git的安装</h2>
<ol>
<li>前往git官网下载git <a href="https://git-scm.com/">点击前往</a></li>
<li>除了这个选项，我选Nano，用着简单，对小白友好哎<img src="https://guohaomeng.github.io/post-images/1573051914315.png" alt=""></li>
<li>其他的一路默认即可(●ˇ∀ˇ●)</li>
<li><img src="https://guohaomeng.github.io/post-images/1573051499964.jpg" alt=""></li>
<li><img src="https://guohaomeng.github.io/post-images/1573051529659.png" alt=""></li>
<li><img src="https://guohaomeng.github.io/post-images/1573051540583.png" alt=""></li>
<li><img src="https://guohaomeng.github.io/post-images/1573051553207.png" alt=""></li>
<li><img src="https://guohaomeng.github.io/post-images/1573051605498.png" alt=""></li>
<li><img src="https://guohaomeng.github.io/post-images/1573051615913.png" alt=""></li>
<li><img src="https://guohaomeng.github.io/post-images/1573051632465.png" alt=""></li>
<li>安装完成啦！<br>
<img src="https://guohaomeng.github.io/post-images/1573051646600.png" alt=""></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于如何在gredia中为网页引入“看板娘”]]></title>
        <id>https://guohaomeng.github.io/post/guan-yu-ru-he-zai-gredia-zhong-wei-wang-ye-yin-ru-kan-ban-niang</id>
        <link href="https://guohaomeng.github.io/post/guan-yu-ru-he-zai-gredia-zhong-wei-wang-ye-yin-ru-kan-ban-niang">
        </link>
        <updated>2019-10-02T12:10:46.000Z</updated>
        <summary type="html"><![CDATA[<p>介绍下引入看板娘的最简单的方法，但注意只能引入不能定制，相当于把别人写好的看板娘拿来放到自己网页上。能定制的以后我找时间再发~</p>
]]></summary>
        <content type="html"><![CDATA[<p>介绍下引入看板娘的最简单的方法，但注意只能引入不能定制，相当于把别人写好的看板娘拿来放到自己网页上。能定制的以后我找时间再发~</p>
<!-- more -->
<h1 id="一-代码准备">一、代码准备</h1>
<pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;&gt;
</code></pre>
<p>这两个是live2d看板娘所需的依赖，一个是jQuery，另一个是fontawesome。gridea这俩好像都没有，我们稍后把它引入。</p>
<pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>autoload.js--自动加载看板娘</p>
<h1 id="二-使用">二、使用</h1>
<p>由于gridea的静态页面都是有对应主题里的模板文件在生成，后同步到GitHub上去的，每次点击同步便会重新生成所有文章页面依次，因此我们应该直接修改模板文件。<br>
进入gridea目录，一般在文档-Gridea文件夹，依次themes-simple-templates-_blocks,找到sidebar.ejs与head.ejs这俩模板文件，在head.ejs中head标签中加入前两行代码<br>
<img src="https://guohaomeng.github.io/post-images/1570021648543.jpg" alt=""><br>
在sidebar.ejs中加入第三行代码<br>
<img src="https://guohaomeng.github.io/post-images/1570021801167.jpg" alt=""><br>
保存一下。再打开gridea，点击同步，用新的模板生成一遍文章，并同步到GitHub。<br>
打开浏览器，访问下博客，好了，看板娘出现在了左下角。<br>
<img src="https://guohaomeng.github.io/post-images/1570022350759.jpg" alt=""></p>
<h1 id="三-over">三、over</h1>
<p>有问题请留言哦~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用VScode写c/c++]]></title>
        <id>https://guohaomeng.github.io/post/yong-vscode-xie-cc</id>
        <link href="https://guohaomeng.github.io/post/yong-vscode-xie-cc">
        </link>
        <updated>2019-08-18T09:04:53.000Z</updated>
        <summary type="html"><![CDATA[<p>本篇文章主要介绍vscode下c/c++的配置，基本原理可以理解为用一个文本编辑器（vscode）+一个编译器（c/c++编译器）组成开发环境，喜欢vscode界面的不要错过。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本篇文章主要介绍vscode下c/c++的配置，基本原理可以理解为用一个文本编辑器（vscode）+一个编译器（c/c++编译器）组成开发环境，喜欢vscode界面的不要错过。</p>
<!-- more -->
<h2 id="第一步下载并安装编译器">第一步，下载并安装编译器</h2>
<p>1.首先，我们去网上下载c/c++编译器 MinGw -64</p>
<p><a href="https://sourceforge.net/projects/mingw-w64/files/">下载地址：https://sourceforge.net/projects/mingw-w64/files/</a></p>
<p>鉴于国内的网络环境，不建议下载在线安装器安装编译器（有可能装不上），这里我们直接下载完整版压缩包，选择最新版本8.1.0中的x86_64-win32-seh(64位系统，开发windows应用程序），单击进行下载。</p>
<p><img src="https://guohaomeng.github.io/post-images/1566121695931.jpg" alt=""><br>
2.下载完成之后可以解压到任意位置。<img src="https://guohaomeng.github.io/post-images/1566121721257.jpg" alt=""><br>
3.添加环境变量。依次开始----设置----系统----关于----系统信息----高级系统设置----环境变量。选中系统变量中的path变量，编辑，新建，填入编译器bin文件夹的路径。OK！<br>
<img src="https://guohaomeng.github.io/post-images/1566125266305.jpg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1566125276247.jpg" alt=""><br>
4.接下来看看是否成功安装了编译器 win+R  填入cmd，运行。键入命令g++ -v，如果出现一大堆东西，就代表安装成功了。<br>
<img src="https://guohaomeng.github.io/post-images/1566122749850.jpg" alt=""></p>
<h2 id="第二部配置vscode">第二部，配置vscode</h2>
<p>1.安装c++扩展。在vscode扩展商店中搜索并安装c/c++，Code Runner这两款扩展。重启vscode使扩展生效。</p>
<p>2.在磁盘某一位置（比如桌面）新建一个文件夹（比如my code)用于存放你将来的c/c++源程序文件。在vscode中单击 文件--打开文件夹，打开刚建好的文件夹。新建一个文件，如001.cpp，写下如下代码。</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main()
{
    cout &lt;&lt; &quot;hello,world&quot; &lt;&lt; endl;
		int n;
		cin&gt;&gt;n;
    return 0;
}
</code></pre>
<p>3.按F5编译，这时会提醒你配置c/c++编译器，总共需要配置lanuch.json及task.json两个配置文件。配置过程如下图<br>
<img src="https://guohaomeng.github.io/post-images/1566124088049.jpg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1566124096108.jpg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1566124102343.jpg" alt=""><br>
4.CTRL+s保存，此时再回到001.cpp文件，再按F5，去配置任务文件<br>
<img src="https://guohaomeng.github.io/post-images/1566124345036.jpg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1566124353610.jpg" alt=""><br>
前面配置好编译器后，这里就不用多task.json文件做任何改动。CTRL+S保存一下<br>
5.再度切回001.cpp，按下F5（编译+运行）；<br>
<img src="https://guohaomeng.github.io/post-images/1566124773897.jpg" alt=""><br>
弹出小黑窗，大功告成！</p>
<h2 id="最后">最后</h2>
<p>告诉大家一个命令行里手动编译cpp/c文件的命令，比如编译上面的那个001.cpp</p>
<pre><code>cd C:\Users\meng\Desktop\my code    //首先切换到该文件目录下
g++ 001.cpp -o 001          //-o是重命名，g++后跟源文件名，C语言的源文件也可以用g++命令编译
./001.exe                            //运行生成的可执行文件
</code></pre>
<p>如图：<br>
<img src="https://guohaomeng.github.io/post-images/1566126298549.jpg" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用vscode写网页----基础安装篇]]></title>
        <id>https://guohaomeng.github.io/post/yong-vscode-xie-wang-ye-ji-chu-an-zhuang-pian</id>
        <link href="https://guohaomeng.github.io/post/yong-vscode-xie-wang-ye-ji-chu-an-zhuang-pian">
        </link>
        <updated>2019-08-10T11:14:48.000Z</updated>
        <summary type="html"><![CDATA[<p>在前端开发中，有一个非常好用的工具，Visual Studio Code，简称VS code。今天就给大家简单介绍下它的使用方法</p>
]]></summary>
        <content type="html"><![CDATA[<p>在前端开发中，有一个非常好用的工具，Visual Studio Code，简称VS code。今天就给大家简单介绍下它的使用方法</p>
 <!-- more --> 
<h2 id="1为什么用vscode">1.为什么用vscode？</h2>
<p>当然是vscode有着数不完的优点呀</p>
<ul>
<li>开源，免费；</li>
<li>自定义配置</li>
<li>集成git</li>
<li>智能提示强大</li>
<li>支持各种文件格式（html/jade/css/less/sass/xml）</li>
<li>调试功能强大</li>
<li>各种方便的快捷键</li>
<li>强大的插件扩展<br>
对前端这么好，没理由不用啊<br>
vscode官网：<a href="https://code.visualstudio.com/">点击前往</a></li>
</ul>
<h2 id="2下载安装vscode并进行开发前的简单配置">2.下载安装vscode，并进行开发前的简单配置</h2>
<p>来到vscode官网，点击下载<br>
<img src="https://guohaomeng.github.io/post-images/1565442330218.jpg" alt=""><br>
打开下载好的安装程序，如图所示操作<br>
<img src="https://guohaomeng.github.io/post-images/1565442410159.jpg" alt=""><br>
装好后打开，你会发现界面全是英文。别紧张，接下来装个简体中文插件就好了<br>
点击侧边第五个图标（扩展按钮）如图<br>
<img src="https://guohaomeng.github.io/post-images/1565442545655.jpg" alt=""><br>
搜索Chinese<br>
<img src="https://guohaomeng.github.io/post-images/1565442571940.jpg" alt=""><br>
就是第一个插件了，点击安装就好了。<br>
安装完重启VScode，变成中文了。<br>
<img src="https://guohaomeng.github.io/post-images/1565442671280.jpg" alt=""><br>
为了确保我们vscode在写HTML代码时用起来更舒适，除了简体中文插件，推荐同时安装以下几个插件（也是搜索安装）：</p>
<ol>
<li>One Dark Pro      深受程序员欢迎的且很漂亮的一款主题插件</li>
<li>open in browser  安装后可通过ALT+B 组合快捷键方便的在默认浏览器中打开当前正在编辑的网页，可通过ALT+shift +B 在其他浏览器中打开当前网页</li>
<li>Preview on web Server    这个也很厉害，大家看图就明白了（按CTRL+shift+V打开）<img src="https://guohaomeng.github.io/post-images/1565443562731.jpg" alt=""></li>
<li>vscode icons   vscode上的文件图标库。</li>
</ol>
<h2 id="3正式开始写代码喽">3.正式开始写代码喽</h2>
<p>首先，在你硬盘某个位置建立一个文件夹，作为你以后各种网页代码的存放地。比如在e盘新建个名为“网页设计”的文件夹。打开vscode，左上角 依次 文件---打开文件夹，在弹出的窗口中选中新建好的文件夹，点击打开。<br>
<img src="https://guohaomeng.github.io/post-images/1565444180439.jpg" alt=""><br>
新建一个名为index.html的文件，写个hello，world试试，这里有个小技巧，英文输入状态下打出感叹号，再按TAB键，可以自动生成最基本的网页结构。如下视频所示<br>
<video width="100%" height="" controls="controls" autoplay="autoplay"><br>
<source src="../../otherfiles/video/video3.mp4" type="video/mp4" /><br>
看到这句话说明你的浏览器不支持HTML5的video标签<br>
</video><br>
写上hello，world！<br>
<img src="https://guohaomeng.github.io/post-images/1565445716854.jpg" alt=""><br>
好了，大功告成！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[低配版音频可视化（c++版）]]></title>
        <id>https://guohaomeng.github.io/post/di-pei-ban-yin-pin-ke-shi-hua-cban</id>
        <link href="https://guohaomeng.github.io/post/di-pei-ban-yin-pin-ke-shi-hua-cban">
        </link>
        <updated>2019-07-21T11:49:16.000Z</updated>
        <summary type="html"><![CDATA[<p>在命令行里一行行打出wav音频文件的时域波形图</p>
]]></summary>
        <content type="html"><![CDATA[<p>在命令行里一行行打出wav音频文件的时域波形图</p>
<!-- more -->
<p>这么做可以用来分析某段音频的振幅，以便据此分析出该声音的种类及特性<br>
运行结果类似下面这张图<br>
<img src="https://guohaomeng.github.io/post-images/1563710493400.jpg" alt=""><br>
具体代码如下：</p>
<pre><code>//
//  test.cpp
//  PCM3.0    解码效率低 卡顿十分严重
//  绘制时域波形图，星星数量代表值的大小。
//

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;windows.h&gt;

using namespace std;

struct wav_struct
{
    unsigned long file_size;       //文件大小
    unsigned short channel;        //通道数
    unsigned long frequency;       //采样频率
    unsigned long Bps;             //Byte率
    unsigned short sample_num_bit; //一个样本的位数
    unsigned long data_size;       //数据大小
    unsigned char *data;           //音频数据
};

int printstar2(double p1)
{
    int p = p1;
    if (p &lt; 0 &amp;&amp; p &gt; -50)
    {
        for (int i = 0; i &lt; (50 + p); i++)
        {
            cout &lt;&lt; &quot; &quot;;
        }
        for (int i = 0; i &lt; (-p); i++)
        {
            cout &lt;&lt; &quot;*&quot;;
        }
        cout &lt;&lt; endl;
    }
    else if (p == 0)
    {
        for (int i = 0; i &lt; 50; i++)
        {
            cout &lt;&lt; &quot; &quot;;
        }

        cout &lt;&lt; &quot;|&quot;;
        cout &lt;&lt; endl;
    }
    else if (p &gt; 0)
    {
        for (int i = 0; i &lt;= 50; i++)
        {
            cout &lt;&lt; &quot; &quot;;
        }
        for (int i = 0; i &lt; p; i++)
        {
            cout &lt;&lt; &quot;*&quot;;
        }
        cout &lt;&lt; endl;
    }
    else
        cout &lt;&lt; p &lt;&lt; endl;
}

int main(int argc, char **argv)
{
    fstream fs;
    wav_struct WAV;

    fs.open(&quot;./Alarm02.wav&quot;, ios::binary | ios::in); //要分析的音频文件路径，这里是源程序目录下的dogbarks.wav文件

    fs.seekg(0, ios::end); //用c++常用方法获得文件大小
    WAV.file_size = fs.tellg();

    fs.seekg(0x14);
    fs.read((char *)&amp;WAV.channel, sizeof(WAV.channel));

    fs.seekg(0x18);
    fs.read((char *)&amp;WAV.frequency, sizeof(WAV.frequency));

    fs.seekg(0x1c);
    fs.read((char *)&amp;WAV.Bps, sizeof(WAV.Bps));

    fs.seekg(0x22);
    fs.read((char *)&amp;WAV.sample_num_bit, sizeof(WAV.sample_num_bit));

    fs.seekg(0x28);
    fs.read((char *)&amp;WAV.data_size, sizeof(WAV.data_size));

    WAV.data = new unsigned char[WAV.data_size];

    fs.seekg(0x2c);
    fs.read((char *)WAV.data, sizeof(char) * WAV.data_size);

    int m = 0;
    for (unsigned long i = 0; i &lt; WAV.data_size; i = i + 400) //可调节打印行数
    {
        //右边为大端
        unsigned long data_low = WAV.data[i];
        unsigned long data_high = WAV.data[i + 1];
        double data_true = data_high * 256 + data_low;
        long data_complement = 0;
        //取大端的最高位（符号位）
        int my_sign = (int)(data_high / 128);

        if (my_sign == 1)
        {
            data_complement = data_true - 65536;
        }
        else
        {
            data_complement = data_true;
        }

        setprecision(4);
        double float_data = (double)(data_complement / (double)32768);
        double starnumber1 = float_data * 100;
        printstar2(starnumber1);
        //printf(&quot;%f &quot;, float_data);
        Sleep(10); //调节屏幕滚动速度
        m++;
    }
    fs.close();
    cout &lt;&lt; &quot;文件大小为  ：&quot; &lt;&lt; WAV.file_size &lt;&lt; endl;
    cout &lt;&lt; &quot;音频通道数  ：&quot; &lt;&lt; WAV.channel &lt;&lt; endl;
    cout &lt;&lt; &quot;采样频率    ：&quot; &lt;&lt; WAV.frequency &lt;&lt; endl;
    cout &lt;&lt; &quot;Byte率      ：&quot; &lt;&lt; WAV.Bps &lt;&lt; endl;
    cout &lt;&lt; &quot;样本位数    ：&quot; &lt;&lt; WAV.sample_num_bit &lt;&lt; endl;
    cout &lt;&lt; &quot;音频数据大小：&quot; &lt;&lt; WAV.data_size &lt;&lt; endl;
    cout &lt;&lt; &quot;总计打印行数：&quot; &lt;&lt; m &lt;&lt; endl;

    delete[] WAV.data;
    int n;
    cout &lt;&lt; &quot;出现的数字代表星星的数量，输入任意值结束程序&quot;;
    cin &gt;&gt; n;
}
</code></pre>
<p>源程序及测试文件：<a href="../../otherfiles/audiotest.zip">点此下载</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[试一试视频]]></title>
        <id>https://guohaomeng.github.io/post/shi-yi-shi-shi-pin</id>
        <link href="https://guohaomeng.github.io/post/shi-yi-shi-shi-pin">
        </link>
        <updated>2019-06-21T13:54:33.000Z</updated>
        <summary type="html"><![CDATA[<p>看看能不能放上视频（推荐使用chrome浏览器）</p>
]]></summary>
        <content type="html"><![CDATA[<p>看看能不能放上视频（推荐使用chrome浏览器）</p>
 <!-- more --> 
<p>视频大概93MB，1m15s<br>
look！<br>
<br></p>
 <video width="100%" height="" controls="controls" autoplay="autoplay">
		<source src="../../otherfiles/video/video1.mp4" type="video/mp4" />
	看到这句话说明你的浏览器不支持HTML5的video标签
</video>
	底下是这次测试视频用的代码
	<br>
<p><img src="https://guohaomeng.github.io/post-images/1561181015756.jpg" alt=""><br>
<br><br>
分割线</p>
<hr>
<p><img src="https://guohaomeng.github.io/post-images/1561367139373.png" alt=""><br>
<br><br>
视频中的转场：<a href="../../otherfiles/zhuanchang.zip">10个无缝转场</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[40道c++程序填空题（2）]]></title>
        <id>https://guohaomeng.github.io/post/40-dao-ccheng-xu-tian-kong-ti-2</id>
        <link href="https://guohaomeng.github.io/post/40-dao-ccheng-xu-tian-kong-ti-2">
        </link>
        <updated>2019-06-08T13:24:28.000Z</updated>
        <summary type="html"><![CDATA[<p>第二版</p>
]]></summary>
        <content type="html"><![CDATA[<p>第二版</p>
<!-- more --> 
<p>传送门1：<a href="../../../otherfiles/c++.html">网页版</a></p>
<p>传送门2：<a href="../../../otherfiles/C++%E7%A8%8B%E5%BA%8F%E9%A2%98%E5%A4%8D%E4%B9%A0.docx">word版</a></p>
<p>传送门3：<a href="../../../otherfiles/index3.html">图片版</a></p>
<pre><code>C++程序填空复习
Test1：
#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
using namespace std;
int main(){
double a,b,c;
double delta,x1,x2;
const double zero=1e-9;//定义一个很小的常数
int sign;
cout&lt;&lt;“输入三个系数a(a!=0),b,c:”&lt;&lt;endl;
cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;//输入a、b、c的值
if（fabs(a)&lt;zero）{ //绝对值很小的数即被认为是0
cout&lt;&lt;“二次项系数为0，方程的根是-c/b”；
exit(0);
}
cout&lt;&lt;“a=”&lt;&lt;a&lt;&lt;’\t’&lt;&lt;“b=”&lt;&lt;b&lt;&lt;’\t’&lt;&lt;”c=”&lt;&lt;c&lt;&lt;endl;
delta=b*b-4*a*c;
if(fabs(delta)&lt;zero){
cout&lt;&lt;“方程有两个相等的实根：”；
cout&lt;&lt;“x1=x2=”&lt;&lt;-b/(2*a)&lt;&lt;endl;
}else{
   if(delta&gt;0) sign=1;
   else sign=0;
   delta=sqrt(fabs(delta));
   x1=-b/(2*a);
   x2=delta/(2*a);
   if(sign!=0){
      cout&lt;&lt;“方程有两个不同的实根：”；
      cout&lt;&lt;”x1=”&lt;&lt;x1+x2&lt;&lt;’\t’&lt;&lt;”x2=”&lt;&lt;x1-x2&lt;&lt;endl;
}else {// sign==0
      cout&lt;&lt;“方程有两个不同的复数根：”；
      cout&lt;&lt;“x1=”&lt;&lt;x1&lt;&lt;“+i”&lt;&lt;x2&lt;&lt;’\t’&lt;&lt;“x2=”&lt;&lt;x1&lt;&lt;”-I”&lt;&lt;x2&lt;&lt;endl;
   }
 }return 0;
}
Test2:设计程序将输入夫人百分制成绩转化为五分制输出，90分以上为5分，80~89分为四分，70~79分为3分，60~69分为2分，60分以下为1分.（提示：百分制成绩的分档用整除10的方法实现）
#include &lt;iostream&gt;// [1]
using namespace std;
int main() {
	int mark, result;	//mark是百分制成绩，result是5分制
	cout&lt;&lt;&quot;请输入百分制成绩：&quot;&lt;&lt;endl;
	cin&gt;&gt;mark;
	if(mark&lt;0) {
		cout&lt;&lt;&quot;缺考！&quot;&lt;&lt;endl;
		return 0;
	}
	switch(mark/10) {  //对百分制成绩进行分档 [2](mark]
		case 10:
		case 9 ://[3]case 9:
			result=5;
			cout&lt;&lt;&quot;输出五分制成绩：&quot;&lt;&lt;result&lt;&lt;endl;
			break;
		case 8:
			result=4;
			cout&lt;&lt;&quot;输出五分制成绩：&quot;&lt;&lt;result&lt;&lt;endl;
			break; //[4]break;
		case 7:
			result=3;
			cout&lt;&lt;&quot;输出五分制成绩：&quot;&lt;&lt;result&lt;&lt;endl;
			break;
		case 6:
			result=2;
			cout&lt;&lt;&quot;输出五分制成绩：&quot;&lt;&lt;result&lt;&lt;endl;
			break;
		case 5:	case 4:	case 3:	case 2:	case 1:	case 0:
			result=1;
			cout&lt;&lt;&quot;输出五分制成绩：&quot;&lt;&lt;result&lt;&lt;endl;
			break;
		default:
			cout&lt;&lt;&quot;输入错误！&quot;&lt;&lt;endl;
	}
}
Test3:输入n，求1！+2！+3！+…+n!。（提示：通常求和作为外循环，阶乘作为内循环）
using namespace std; 
【1】int main(){
	int n, i, jch;  //jch是阶乘
	double result=0;  //result是结果
	【2】	cin&gt;&gt;n;  //输入n的值
	if(n&lt;1) {
		cout&lt;&lt;&quot;输入错误！&quot;&lt;&lt;endl;
		return 0;
	}
	result=1;
	for(i=2,jch=1; i&lt;=n; 【3】 i++) {
		【4】jch=jch*i;  //计算阶乘
		result+=jch;
	}
	cout&lt;&lt;result&lt;&lt;endl;
	return 0;
}
Test4：编写一个函数，将一个数插入到已是升序的数组中，且插入后该数组仍是升序数组。已是升序数组的内容由主函数给出，待插入的数在主函数中输入。
#include &lt;iostream&gt;
using namespace std;
int main() {
	int i, j, number, a[11]= {1,2,4,6,8,9,12,15,20,30};
	cout&lt;&lt;&quot;请输入一个数:&quot;;
	cin&gt;&gt;number;  //输入number的值
	cout&lt;&lt;&quot;开始的数组:&quot;;
	for(i=0; i&lt;10; i++)
		cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;
	cout&lt;&lt;endl;
	i=0;
	while (i&lt;10&amp;&amp;number&gt;=a[i]) i++;
	for(j=10; j&gt;=i; j--)
		a[j]=a[j-1];
	a[i]=number;
	cout&lt;&lt;&quot;插入后的数组:&quot;;
	for(i=0; 【4】i&lt;11; i++)
		cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;
	return 0;
}
Test5：编程找出1~500之中满足除以3余2，除以5余3，除以7余2的整数。
【1】#include &lt;iostream&gt;
using namespace std;
int main() {
	int i;
	for(i=1; 【2】i&lt;=500; i++)
		if((i%3==2)&amp;&amp;(i%5==3)&amp;&amp;【3】i%7==2 )
			【4】cout&lt;&lt;i&lt;&lt;endl;
	return 0;
}
Test6：编程求1000之内的所有完全数。所谓完全数是指一个。例如6=1+2+3，就是一个完全数。（提示：采用穷举法。两两循环，外层是1到999依次处理，内层是求该数的所有因子之和）
#include &lt;iostream&gt;
【1】using namespace std;
int main() {
	int i, a, sum;	//sum是a的因子和
	for(【2】a=1; a&lt;1000; a++) {
		sum=0;
		for(i=1; i&lt;a; i++)
			if(a%i==0 ) 【3】sum+=i;  //如果i是a的一个因子，则求因子和
		if(【4】sum==a)  //如果这个数等于它的所有因子和
			cout&lt;&lt;a&lt;&lt;endl;
	}
	return 0;
}
Test7：设计函数factors(num,k),返回值整数num包含因子k的个数，如果没有该因子，则返回0。
#include &lt;iostream&gt;
using namespace std;
int factors(int num, int k) { 
	int count=0;  //count用来统计个数
	while (num%k==0) {
		【1】count++;
		num/=k;
	}
	【2】return count;
}
【3】int main(){  //
	【4】cout&lt;&lt;&quot;factors(64,3)=&quot;&lt;&lt;factors(64,3)&lt;&lt;endl;
	return 0;
}
Test8:函数myStrCat(char*dst,char*src)将字符串src连接到字符串dst的后面，填写适当的代码，是的mySum（）完成正确的功能。
#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;
char myStrCat(char *dst, char *src) ; //myStrCat函数的声明
int main() {        
    void dst[100]=&quot;Hello, &quot;;
    char src[100]=&quot;Good luck!&quot;;
    myStrCat(dst, src);
    cout &lt;&lt; dst &lt;&lt; endl;
    return 0;
}
   void myStrCat(char *dst, char *src) {//【3】______ 
    int i=0, len;
    len = strlen(dst);
while(src[i]) {
   dst[len] = src[i];
    len++;
    i++;
}
    dst[len] = '\0';
}
Test9：定义max函数实现求三个实数中的最大值。
#include&lt;iostream&gt;
using namespace std;
double max(double a, double b, double c) {//【1】______ 
	if(a&gt;b&amp;&amp;a&gt;c) return a;
	if(b&gt;a&amp;&amp;b&gt;c) return b;//[2]
	return c;//[3]
}
int main() {
   cout&lt;&lt;max(3.2,7.4,4.5)&lt;&lt;endl;//[4]
    return 0;
}
Test10:编写函数getSum()，求整数m的各位数字之和并返回该值。例如m=25时，各位数字之和为9。
#include&lt;iostream&gt;//【1】______
using namespace std;
int getSum(int m);
int main() {
	int m,s=0;
	m=252;
	s=getSum(m);//【2】______;  求m的各位数字之和并赋值给s
	cout&lt;&lt;s;
	return 0;
}
int getSum(int m) {  //求m的各位数字之和
	int s=0,n;  //n记录各个位上的数字
	while(m!=0) {
		n=m%10;//【3】______;  求m各个位上的数字
		s+=n;
		m=m/10;
	}
	return s;//[4]
}
Test11:编写函数reverse，对给定的10个数置逆序排列。
#include&lt;iostream&gt;
using namespace std;
#define N 10  //[1]符号常量的定义
void reverse(int a[], int len) { //a是待操作的数组，len是数组中元素的数目
	int i, t;
	for(i=0;i&lt;N/2; i++) {//[2]
		t = a[i];
		a[i]=a[N-1-i];//[3]
		a[N-1-i]=t;
	}
}
int main() {
	int a[N], k;
	for(k=0; k&lt;N; k++)
		cin&gt;&gt;a[k];//[4]
	reverse(a,N);
	for(k=0; k&lt;N; k++)
		cout&lt;&lt;a[k]&lt;&lt;endl;
	return 0;
}
Test12：函数compare比较两个长度为N的数组是否相等（即两个数组中下标相同的数组元素均相等）。请完成该函数。
#include &lt;iostream&gt;
using namespace std;
void compare(int a[], int b[], int n) {
	bool equal = true;//[1]
	for(int index=0; index&lt;n; index++) {
		if(a[index] != b[index]) {
			equal = false;//[2]
		 //[3]
		}
	}
	if(equal==true)
		cout &lt;&lt; &quot;Equal!&quot; &lt;&lt; endl;
	else
		cout &lt;&lt; &quot;Not equal!&quot; &lt;&lt; endl;
}

void input(int a[], int b[], int n) {
	int index;
	 for(index=0; index&lt;n; index++) {//[4]
		cin &gt;&gt; a[index];
	}
	for(index=0; index&lt;n; index++) {
		cin &gt;&gt; b[index];
	}
	
}
int main() {
	int a[5], b[5];
	input(a, b, 5);
	compare(a, b, 5);
	return 0;
}
Test13：编写一个函数void changeString(char str[]);功能是把其中的大写字母变成小写字母，小写字母变成大写字母，非字母的字符不作变换。变换结果依旧保存在str数组内。大写字母的ASCII码值比对应的小写字母 的ASCII码值小32，如A的ASCII码值比a的ASCII码值小32.
#include &lt;iostream&gt;
using namespace std;
void changeString(char str[]) {
	for(int i=0; str[i]!='\0'; i++) {//[1]
		if(str[i]&gt;='a'&amp;&amp;str[i]&lt;='z')
			str[i]-= 32;//【2】______
		else if(str[i]&gt;='A'&amp;&amp;str[i]&lt;='Z')
			str[i] += 32;
	}
}
int main() {
	char str[50];//[3]
	cout&lt;&lt;&quot;输入要变换的字符串：&quot;;
	cin&gt;&gt;str;
	changeString(str);//[4]
	cout&lt;&lt;&quot;变换结果是：&quot;&lt;&lt;str&lt;&lt;endl;
	return 0;
}
Test14：
#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;
void conv(char s[]);//conv函数的声明
int main(){
char s[10];
int i;
cin&gt;&gt;s;
conv(s);
cout&lt;&lt;s&lt;&lt;endl;
return 0;
}
void conv(char *s) {
int len = strlen(s), j,c;
for (j=0;j&lt;len/2; j++) {
char c = s[j];
s[j]= s[len-1-j];
s[len-1-j]=c;
}
}

Test15：利用冒泡法将10个数按降序排列。
#include&lt;iostream&gt;
using namespace std;
int main() {
	int arr[10],i,j,k;
	 for(i=0;i&lt;10;i++)//遍历数组元素进行赋值[1]
		cin&gt;&gt;arr[i];
	for(i=0; i&lt;10; i++) {
       for(j=0; j&lt;10; j++) {//[2]
			if(arr[j]&lt;arr[j+1]) {//[3]
				k=arr[j+1];
				arr[j+1]=arr[j];
				arr[j]=k;
			}
		}
	}
	for(i=0; i&lt;10; i++)
		cout&lt;&lt;arr[i] &lt;&lt;&quot; &quot;;//[4]
	return 0;
}
Test16：声明人民币类IntRMB,私有数据成员包括：元（IYuan）、角（Jiao）、分（Fen），均为整形。类型转换函数将人民币类强制转化为浮点数，以“元”为单位。例如：“10元25角3分”转换成“12.53元”。（参考：类类型可以通过类型转换函数实现类型强制转换，它只能是类的成员函数，不能是友元函数。格式为：operator转换后的数据类型（）{…}使用时的格式为：转换后的数据类型（对象名）；或（转换后的数据类型）对象名；）
#include &lt;iostream&gt;
using namespace std;
class IntRMB {  //人民币类
private:  //访问属性
		int IYuan;
		int Jiao;
		int Fen;
	public:
		IntRMB(int y=0,int j=0,int f=0);  //构造函数的声明
		void print();
		operator float() {  //float类型转换函数的定义
			float temp;
			temp=float(IYuan+(Jiao/10.0)+(Fen/100.0));
			return temp;
		}
};
IntRMB::IntRMB(int y,int j,int f) { //构造函数的实现
	IYuan=y;
	Jiao=j;
	Fen=f;
}
void IntRMB::print() {
	cout &lt;&lt;IYuan &lt;&lt; &quot;元&quot; &lt;&lt;Jiao &lt;&lt; &quot;角&quot; &lt;&lt;Fen &lt;&lt;&quot;分&quot; &lt;&lt;endl;
}
int main() {
	float a;
	IntRMB m(10,25,3); //定义人民币对象
	cout &lt;&lt; &quot;***转换前***&quot; &lt;&lt;endl;
	m.print();
	a=(float)m
..;  //使用重载类型float进行强制类型转换
	cout &lt;&lt; &quot;***转换后***&quot; &lt;&lt;endl;
	cout&lt;&lt;a&lt;&lt;&quot;圆&quot;&lt;&lt;endl;
	return 0;
}
Test17：生命complex类表示负数类型，私有数据成员表示其实部，img表示其虚部。在类中以成员函数的形式定义运算符+的重载函数实现两个复数的加法，并返回结果。
#include &lt;iostream&gt;
using namespace std;
class Complex {
private:	
	float real;
	float img;
public:
	Complex(float r=0, float i=0):real(r),img(i) {}
	//定义运算符+的成员重载函数，形参是Complex对象的常引用two
	 Complex operator+(Complex&amp;two){//[1]
		return Complex(real+two.real,img+two.img );//[2]
	}
	void display(){
		cout&lt;&lt;&quot;加法的结果为：&quot;&lt;&lt;real;//[3]
		if(img&gt;=0) cout &lt;&lt; &quot;+&quot;; //如果虚部为负数，负数本身有一个&quot;-&quot;号
		cout &lt;&lt;img&lt;&lt;&quot;i&quot;&lt;&lt;endl;
	}
};
int main() {
	Complex one(1.3,-5.2),two(3.7,2.1),result;
	result=one+two;  //计算复数one和two的加法[4]
	result.display();
	return 0;
}
Test18：有一个Time类，数据成员有时，分，秒。要求模拟秒表，每次走一秒，满60秒进位，秒又从零开始计数；满60分进位，分又从零开始计数；时使用24小时制，并以“时：分：秒”的格式输出时间。
#include &lt;iostream&gt;
using namespace std;
class Time {
public:
	//在Time类的构造函数中使用成员初始化列表初始化数据成员
	Time(int h=0, int m=0, int s=0): hour(h),minute(m),sec(s) {}//【1】 
	Time operator++() {  //前置++运算符重载函数
	sec++;
	if(sec&gt;=60)  {//【2】 
		sec=sec-60;
		minute++;
		if(minute&gt;=60) {
			minute=minute-60;
			hour++;
			if(hour&gt;24)  hour=hour%24;//【3】 
		}
	}
	return *this;
	}
Time operator++(int) {//【4】  //后置++运算符重载函数
	Time temp(*this);  //保存修改前的对象做返回值
	++(*this);
	return temp;
	}
 void Time::display() {
	cout&lt;&lt;hour&lt;&lt;&quot;:&quot;&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;sec&lt;&lt;endl;
	}
private:
	int hour ;
	int minute;
	int sec;
};
int main()
{
	Time time1(21,34,59), time2;
	cout&lt;&lt;&quot; time1 : &quot;;	
        time1.display();
	++time1;
	cout&lt;&lt;&quot;++time1: &quot;;	
        time1.display();
	time2 = time1++;
	cout&lt;&lt;&quot;time1++: &quot;;	
        time1.display();
	cout&lt;&lt;&quot; time2 : &quot;;	
        time2.display();
	return 0;
}
Test19：利用函数模板设计一个求所有数组元素的和的函数。
#include &lt;iostream&gt;
using namespace std;
template&lt;typename T&gt;
T  sum(T a[],int n){//求数组a所有元素的和
int i;
T s=0;
for(i=0;i&lt;n;i++)
s = s + a[i];
return  s;
}
int main() {
int a[5]={1,2,3,4,5}, s;
s=sum(a,5); //求数组a所有元素的和
cout&lt;&lt;s&lt;&lt;endl;
return 0;
}
Test20：用函数模板实现3个数值的升序排列。
#include &lt;iostream&gt;
using namespace std;
template &lt;typename T&gt;//[1]
void sort(T a, T b, T c) {
	int array[3], temp;//[2]
	array[0] = a;
	array[1] = b;
	array[2] = c;
	int i,j;
	for(i=0;i&lt;3;i++) {
		for(j=0;j&lt;2;j++)
			if(array[j]&gt;array[j+1]) { //[3]如果条件为真，则交换两个数的位置
				temp = array[j];
				array[j] = array[j+1];
				array[j+1]=temp;//【4】______
			}
	}
	cout&lt;&lt; array[0]&lt;&lt; ' ' &lt;&lt; array[1]&lt;&lt; ' ' &lt;&lt; array[2]&lt;&lt; endl;
}
int main() {
	sort(15,10,9);
	return 0;
}
Test21：编写一个程序，该程序使用new运算符建立一个动态的double数组，然后为数组元素赋值，并显示元素值，最后使用delete运算符释放这个动态数组。
#include&lt;iostream&gt;//【1】______
using namespace std;
int main() {
	int i, n, temp=0;
	cout&lt;&lt;&quot;输入数组大小:&quot;;
	cin&gt;&gt;n;  //输入需要的数组大小
	double *array = new double[n];//【2】______;  //动态申请数组
	cout&lt;&lt;&quot;给每个数组元素赋值：&quot;&lt;&lt; endl;
	for(i=0; i&lt;n; i++) {
		cout&lt;&lt;&quot;array[&quot;&lt;&lt; i &lt;&lt;&quot;] = &quot;;
		cin&gt;&gt;array[i];//【3】______;  //输入各个数组元素的值
	}
	cout&lt;&lt;&quot;动态数组个元素的值如下：&quot;&lt;&lt; endl;
	for(i=0; i&lt;n; i++) {
		cout&lt;&lt;&quot;array[&quot;&lt;&lt; i &lt;&lt;&quot;] = &quot;&lt;&lt; array[i] &lt;&lt; endl;  //打印数组元素
	}
	delete[] array;  //[4]释放动态数组
	return 0;
}
Test22：设计一个圆类，从圆类派生圆柱，用成员函数输出它们的面积和体积。
#include &lt;iostream&gt;
using namespace std;
class Circular { //圆类
	public:
		Circular(double a) {  //[1]圆类的构造函数
			r = a;
			area = 3.1415926 * r * r;
		}
		double getArea() { //计算圆面积
			return area;
		}
	private:  //[2]数据成员的访问属性
		double r;
		double area;
	
};
class Column: public Circular { //从圆类派生圆柱类
	protected:
		double h;
		double cubage;
	public:
		Column(double a, double b) :Circular(a) {  //[3]成员初始化
			h = b;   //派生类数据成员的赋值
			cubage = getArea() * h;
		}
		double getCubage() { //计算圆柱体积
			return cubage;
		}
};
int main() {
	Circular circular(45);
	Column column(12, 10);
	cout&lt;&lt;&quot;圆的面积：&quot;&lt;&lt; circular.getArea() &lt;&lt; endl;  //[4]输出圆的面积
	cout&lt;&lt;&quot;圆柱的体积：&quot;&lt;&lt; column.getCubage() &lt;&lt; endl;
	return 0;
}
Test23:
#include&lt;iostream&gt;
using namespace std;
class Box{//类的声明
public:
int wight;
int length;
int high;
void box_shape(int w,int l,int h);
int box_volume(int w,int l,int h);
int box_area(int w,int l,int h);
};
void Box::box_shape(int w,int l,int h){//判断盒子的形状
if((w==l)&amp;&amp;(l==h))
   cout&lt;&lt;“这是一个正方体！”&lt;&lt;endl;
else
   cout&lt;&lt;“这是一个长方体！”&lt;&lt;endl;
}
int main(){
   Box mybox;//对象定义
cout&lt;&lt;“请输入盒子的长、宽、高：”；
cin&gt;&gt;mybox.width&gt;&gt;mybox.length&gt;&gt;mybox.hight;
//调用成员函数box_shape判断形状
mybox.box_shape(mybox.width,mybox.length,mybox.hight;
return 0;
}
Test24设计一个圆类，从圆类派生圆柱，用成员函数输出它们的面积和体积

#include &lt;iostream&gt;
using namespace std;
class Box {
private:
	int length;
	int width;
	int hight;
public:  //访问属性  1】______  //访问属性
	Box(int l,int w,int h) {  //构造函数2】______ 
		length = l;
		width = w;
		hight = h;
	}
	int volume() {
		return hight * width * length;
	}
};
int main() {
	Box box1(30, 20, 10);  //定义对象box1 【3】______ box1(30, 20, 10);
		cout &lt;&lt; &quot;Box1's volume = &quot; &lt;&lt; box1.volume() &lt;&lt; endl; //输出box1的体积cout &lt;&lt; &quot;Box1's volume = &quot; &lt;&lt; 【4】______ &lt;&lt; endl;
	return 0;
}
Test25：声明一个模板，利用他们分别实现两个整数和浮点数的比较，输出最大数。
#include &lt;iostream&gt;
using namespace std;
template &lt;class numtype&gt;  //[1]类模板声明
class Compare {
public:
	Compare(numtype a,numtype b) {  //[2]构造函数定义
		x=a;
		y=b;
	}
	numtype max() {//[3]
		return (x&gt;y)?x:y;}
	numtype min(){
	    return (x&lt;y)?x:y;}
private:
	numtype x,y;
};
int main() {
	Compare&lt;int&gt; cmp1(3,4);  //定义对象cmp1实现两个整数的比较
	cout&lt;&lt;cmp1.max()&lt;&lt;&quot; is the Maximum of two inteder numbers.&quot;&lt;&lt;endl;
	cout&lt;&lt;cmp1.min()&lt;&lt;&quot; is the Minimum of two inteder numbers.&quot;&lt;&lt;endl&lt;&lt;endl;
	Compare&lt;float&gt; cmp2(45.78,93.6);  //[4]定义对象cmp2实现两个单精度浮点数的比较
	cout&lt;&lt;cmp2.max()&lt;&lt;&quot; is the Maximum of two float numbers.&quot;&lt;&lt;endl;
	cout&lt;&lt;cmp2.min()&lt;&lt;&quot; is the Minimum of two float numbers.&quot;&lt;&lt;endl&lt;&lt;endl;
	return 0;
}
Test26：建立一个对象数组，内放5个学生的数据（学号，成绩），用指针指向数组的首地址，使用该指针输出第1，3，5个学生的数据。其中，对象数组名必须是stud。
#include&lt;iostream&gt;
using namespace std;
class Student {
public:
	Student(int n,int s):num(n) ,score(s){ } //[1]构造函数使用成员初始化列表进行初始化
	void display() {
		cout&lt;&lt;num&lt;&lt;&quot; &quot;&lt;&lt;score&lt;&lt;endl;
	}
private:
	int num;
	int score;
};
int main() {
	Student stud[5] = {Student(1,70) ,Student(2,71), Student(3,72),//[2]
						Student(4,73), Student(5,74)}; 
	Student *p=stud; 
	for(int i=0; i&lt;=2; i++) {  //输出第1，3，5个学生的数据
		p-&gt;display();  //[3]调用成员函数display
		p=p+2;  //[4]更新指针变量p
	}
	return 0;
}
Test27：建立一个对象数组，内放5个学生的数据（学号，成绩），设立一个函数max，用指向对象的指针作函数参数，在max函数中找出5个学生中成绩最高者，并输出其学号。
#include&lt;iostream&gt;
using namespace std;
class Student {
public:
	Student(int n,int s):num(n),score(s) {}
	int num;
	int score;
};
int max(Student*arr) {  //【1】max函数的参数是一个Student类的指针变量arr
	float max_score=arr[0].score;  //用max_ score记录最高的成绩
	int i, max_num=0;  //用max_num记录成绩最高的学生的学号
	for(i=0; i&lt;3; i++)
	{	if(arr[i].score&gt;max_score) {  //[2]比较大小，并把大值保存在变量max_score中
			max_score=arr[i].score;
			max_num=i+1; }  //[3]更新max_num
	}
	cout&lt;&lt;max_score&lt;&lt;&quot; &quot;&lt;&lt;max_num&lt;&lt;endl;
	return 0;
}
int main() {
	Student stud[3] = {Student(1,70),Student(2,71),Student(3,72)};
	Student *p =&amp;stud[0];  //[4]初始化指向对象数组首地址的指针变量
	max(p);
	return 0;
}
Test28：定义一个复数类Complex，重载运算符“+”，使之能用于复数的加法运算。参加运算的两个运算量可以都是类对象，也可以其中有一个是整数，顺序任意。例如：c1+c2,i+c1,c1+i均合法（设i为整数，c1、c2为复数）。编程序，分别求两个复数之和、整数和复数之和。
#include &lt;iostream&gt;
using namespace std;
class Complex {
private:
	double real;
	double imag;
public:
	Complex() {
		real=0;
		imag=0;
	}
	Complex(double r,double i) {
		real=r;
		imag=i;
	}
	Complex operator+(Complex &amp;c) {  //[1]两个复数的加法，参数使用引用形式
		return Complex(real+c.real, imag+c.imag );
	}
	Complex operator+(int &amp;i) {  //复数+整数，参数使用引用
		return Complex(i+real,imag);//[2]
	}
	friend Complex operator+(int &amp;i,Complex &amp;c);  //[3]友元函数声明
  	void display() {
		cout&lt;&lt;&quot;(&quot;&lt;&lt;real&lt;&lt;&quot;,&quot;&lt;&lt;imag&lt;&lt;&quot;i)&quot;&lt;&lt;endl;
	}
};
Complex operator+(int &amp;i,Complex &amp;c) {  //整数+复数
return Complex(i+c.real,c.imag);
}
int main() {
	Complex c1(3,4),c2(5,-10),c3;  //[4]对象的定义
	int i=5;
	c3=c1+c2;
	cout&lt;&lt;&quot;c1+c2=&quot;;
	c3.display();
	c3=i+c1;
	cout&lt;&lt;&quot;i+c1=&quot;;
	c3.display();
	c3=c1+i;
	cout&lt;&lt;&quot;c1+i=&quot;;
	c3.display();
	return 0;
}
Test29：有两个矩阵a和b，均为2行3列。求两个矩阵之和。重载运算符“+”，使之能用于矩阵相加。如a+b。
#include &lt;iostream&gt;
using namespace std;
class Matrix { //定义Matrix类
public:
	Matrix(); //默认构造函数
	friend Matrix operator+(Matrix &amp;,Matrix &amp;); //【1】运算符&quot;+&quot;的友元重载函数
	void input(); //输入函数
	void display(); //输出函数
private:
	int mat[2][3];
};
Matrix::Matrix() { //定义构造函数
	for(int i=0; i&lt;2; i++)
		for(int j=0; j&lt;3; j++)
			mat[i][j]=0;
}
Matrix operator+(Matrix &amp;a,Matrix &amp;b) { //定义重载运算符&quot;+&quot;函数
	Matrix c;
	for(int i=0; i&lt;2; i++)
		for(int j=0; j&lt;3; j++) {
			c.mat[i][j]=a.mat[i][j]+b.mat[i][j];
		}
	return c;//【2】______;
}
void Matrix::input() { //[3]定义输入函数
	cout&lt;&lt;&quot;input value of matrix:&quot;&lt;&lt;endl;
	for(int i=0; i&lt;2; i++)
		for(int j=0; j&lt;3; j++)
			cin&gt;&gt;mat[i][j];
}
void Matrix::display() { //定义输出函数
	for (int i=0; i&lt;2; i++) {
		for(int j=0; j&lt;3; j++) {
			cout&lt;&lt;mat[i][j]&lt;&lt;&quot; &quot;;
		}
		cout&lt;&lt;endl;
	}
}
int main() {
	Matrix a,b,c;
	a.input();
	b.input();
	cout&lt;&lt;endl&lt;&lt;&quot;Matrix a:&quot;&lt;&lt;endl;
	a.display();
	cout&lt;&lt;endl&lt;&lt;&quot;Matrix b:&quot;&lt;&lt;endl;
	b.display();
	c=a+b;//【4】______; //用重载运算符&quot;+&quot;实现两个矩阵相加
	cout&lt;&lt;endl&lt;&lt;&quot;Matrix c = Matrix a + Matrix b :&quot;&lt;&lt;endl;
	c.display();
	return 0;
}
Test30：声明一个字符串类，用来存放不定长的字符串。重载运算符“==”，用于两个字符串的等于关系的比较运算。
#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;
class MyString {
public:
	MyString() {p=NULL;}
	MyString(char *str) {p=str;}  //数据成员赋值
	friend bool operator==(MyString &amp;string1,MyString &amp;string2);  //友元函数声明
	void display() {cout&lt;&lt;p;}   //输出P所指向的字符串
private:
	char *p;
};
bool operator==(MyString &amp;string1,MyString &amp;string2) {
	if(strcmp(string1.p,string2.p)!=0)	return true;  //比较两个字符串
	else	return false;
}
void compare(MyString &amp;string1,MyString &amp;string2) {
	if(operator==(string1,string2)==0) {  //调用运算符重载函数比较两个字符串
		string1.display();
		cout&lt;&lt;&quot;=&quot;;
		string2.display();
	} else {
		string1.display();
		cout&lt;&lt;&quot;!=&quot;;
		string2.display();
	}
	cout&lt;&lt;endl;
}
int main() {
	MyString string1(&quot;Hello&quot;),string2(&quot;Book&quot;),string3(&quot;Hello&quot;);
	compare(string1,string2); 
	compare(string1,string3);
	return 0;
}
Test31：先建立一个Point（点）类，包含数据成员下，有（坐标点）。以它为基类，派生出一个Circle（圆类，增加数据成员r（半径），再以Circle类为直接基类，派生出一个Cylinder（圆柱体）类，在增加数据成员h（高）。编写程序，重载运算符“&lt;&lt;”和“&gt;&gt;”,使之能够用于输出以上类的对象。
#include &lt;iostream&gt;
using namespace std; 
class Point {
protected:
	int x,y;
public:
	Point() {x=0; y=0;}
	Point(int a, int b) {x=a; y=b;}
	void setX(int a) {x=a;}
	void setY(int b) {y=b;}
	int getX() {return x;}
	int getY() {return y;}
};
class Circle: public Point {
	protected:
		int r;
	public:
		Circle(int x,int y,int r):Point(x,y) {this-&gt;r=r;}
		void setR(int a) {r=a;}
		int getR() {return r;}
};
class Cylinder: public Circle {
	protected:
		int h;
	public:
		Cylinder():Circle(0,0,0),h(0) {}
		Cylinder(int x,int y,int r,int h):Circle(x,y,r) {this-&gt;h = h;}
		void setH(int a) {h=a;}
		int getH() {return h;}
		friend istream &amp; operator&gt;&gt;(istream &amp;, Cylinder &amp;);
		friend ostream &amp; operator&lt;&lt;(ostream &amp;, Cylinder &amp;);
};
istream &amp; operator&gt;&gt;(istream &amp;input, Cylinder &amp;cc) {
	int _x, _y, _r, _h;
	cout&lt;&lt;&quot;Enter the Cylinder: &quot;&lt;&lt;endl;
	cin &gt;&gt;_x &gt;&gt;_y &gt;&gt;_r &gt;&gt;_h;
	cc.setX(_x);
	cc.setY(_y);
	cc.setR(_r);
	cc.setH(_h);
	return input;
}
ostream &amp; operator&lt;&lt;(ostream &amp; output, Cylinder &amp; cc) {
	output&lt;&lt;cc.getX()&lt;&lt;' '&lt;&lt;cc.getY()&lt;&lt;' '&lt;&lt;cc.getR()&lt;&lt;' '&lt;&lt;cc.getH()&lt;&lt;endl;
	return output;
}
int main() {
	Cylinder cc;
	cin&gt;&gt;cc;
	cout&lt;&lt;cc;
	return 0;
}

Test32：写一个程序，定义抽象类Shape，由他派生的三个类：Circle（圆形），Rectangle（矩形），Trapezoid（梯形），用一个函数print Area分别输出三者的面积，3个图形的数据在定义对象是给定的。
// P188
#include &lt;iostream&gt;
using namespace std;
class Shape {  //形状类 
public:
	virtual double area() const=0;  //纯虚函数area()的声明 
};
class Circle: public Shape {  //圆形类 
private:
	double r;
public:
	Circle(double a):r(a) {}  //构造函数的定义
	virtual double area() const {
		return 3.14 * r * r;
	}
};
class Rectangle: public Shape {
private:
	double h, w;
public:
	Rectangle(double a, double b):h(a),w(b) {}  //构造函数的成员初始化列表
	virtual double area() const {
		return h * w;
	}
};
class Trapezoid: public Shape {  //梯形类 
private:
	double h, w;
public:
	Trapezoid(double a, double b):h(a),w(b) {}
	virtual double area() const {
		return 0.5 * h * w;
	}
};
void printArea(const Shape &amp;c) {
	cout &lt;&lt;c.area()&lt;&lt; endl;  //输出对象c的面积
}
int main() {
	Circle c(2);
	printArea(c);
	Rectangle r(2,4);
	printArea(r);
	Trapezoid t(3,5);
	printArea(t);
	return 0;
}
Test33：定义一个学生类Student做基类，再派生一个Graduate类，学生类有学号，姓名，和分数，研究生增加工资，他们有同名的函数display（），利用虚函数，变成分别输出学生和研究生的数据，具体数据自拟。
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
class Student {
protected://【1】______  //声明数据成员的访问属性
	int id;
	string name;
	int score;
public:
	Student(int,string,int);
	virtual void display();
};
Student::Student(int i, string n, int cr) {
	id = i;
	name = n;
	score = cr;
}
void Student::display() {
	cout &lt;&lt; id &lt;&lt; &quot;: &quot; &lt;&lt; name &lt;&lt; endl;
	cout &lt;&lt; score &lt;&lt; endl;
}
class Graduate:public Student  {  //[2]Graduate类公有继承Student类
protected:
	int salary;
public:
	Graduate(int i,string n,int cr,int sa)//【3】______  //构造函数的定义
		:Student(i, n, cr),salary(sa) {}  
	void display();
};
void Graduate::display() {  //[4]Graduate类成员函数display()函数的定义
	cout &lt;&lt; id &lt;&lt; &quot;: &quot; &lt;&lt; name &lt;&lt; endl;
	cout &lt;&lt; score &lt;&lt; endl;
	cout &lt;&lt; salary &lt;&lt; endl;
}
int main() {
	Student stu(1, &quot;John&quot;, 99);
	stu.display();
	Graduate gra(2, &quot;JOHNLIU&quot;, 100, 5000);
	gra.display();
	return 0;
}
Test34商店销售某一商品，商店每天公布统一的折扣（discount）。同时允许销售人员在销售时活掌握售价(price)，在此基础上，对一次购买10件以上者，还可以享受9.8折扣优惠。现在已知当天3名销售员的销售情况为：
售货员工号（num）           售出商品数目（quantity）             商品单价（price）
  101                          5                                23.5
  102                          12                               24.56    
103                          100                              21.5
请编写程序，计算当日此商品的总销售额sum，以及每件商品的平均售价。要求用静态数据成员和静态成员函数。（提示：将折扣discount、总销售额sum和商品总销售数目n声明为静态数据成员，再定义静态成员函数average（求平均售价）和display（输出结果）。

//P145
#include &lt;iostream&gt;
using namespace std;
class Product {
public:
	Product(int n,int q,float p):num(n),quantity(q),price(p) {};
	void total(); //计算总销售额和总销售数目 
	static float average();  //静态average()函数的声明，求平均售价
	static void display(); //输出总销售额和平均售价 
private:
	int num; //售货员工号 
	int quantity; //售出商品数目 
	float price; //商品单价 
	static float discount; //统一的折扣 
	static float sum; //总销售额 
	static int n; //总销售数目 
};
void Product::total() {  
	float rate=1.0;
	if(quantity&gt;10) rate=0.98*rate;
	sum=sum+quantity*price*rate*(1-discount);
	n=n+quantity;
}
void Product::display(){  //静态display()函数的定义
	cout&lt;&lt;sum&lt;&lt;endl;
	cout&lt;&lt;average()&lt;&lt;endl;
}
float Product::average() {
	return(sum/n);
}
float Product::discount =0.05; //静态成员数据discount的初始化
float Product::sum=0;
int Product::n=0;
int main() {
	Product Prod[3]=
           {Product(101,5,23.5),Product(102,12,24.56),Product(103,100,21.5)};
	for(int i=0; i&lt;3; i++)
		Prod[i].total();
	Product::display(); //调用静态成员函数display()输出总销售额和平均售价
	return 0;
}
Test35 请编写程序，处理一个复数与一个double数相加的运算，结果存放在一个double型的变量d1中，输出d1的值，再以复数的形式输出此值。定义Complex（复数）类，在成员函数中包含重载类型转换运算符：operator double（）{return real；}。

#include &lt;iostream&gt;
using namespace std;
class Complex {
public:
	Complex() {
		real=0;
		imag=0;
	}
    	Complex(double r){ //类型转换构造函数，将double类型转换为Complex类型
		real=r;
		imag=0;
	}
	Complex(double r,double i) {
		real=r;
		imag=i;
	}
	operator double(){ //类型转换成员函数，将Complex类型转换为double类型
		return real;
	}
	void display();
private:
	double real;
	double imag;
};
void Complex::display() {
	cout&lt;&lt;&quot;(&quot;&lt;&lt;real&lt;&lt;&quot;, &quot;&lt;&lt;imag&lt;&lt;&quot;)&quot;&lt;&lt;endl;
}
int main() {
	Complex c1(3,4),c2;
	double d1;
	d1=c1+2.5 ;// double型常量2.5与复数c1相加，运算结果存放在d1中
	cout&lt;&lt;&quot;d1=&quot;&lt;&lt;d1&lt;&lt;endl;
	c2=d1; //将double型变量d1转换为复数类型
	cout&lt;&lt;&quot;c2=&quot;;
	c2.display();
	return 0;
}
Test36 有一个Time类，包含数据成员mintue(分)和sec（秒），模拟秒表，每次走疫苗，满60秒进一分钟，此时秒又从0开始算。要求输出分和秒的值，且对后置自增运算符的重载。
#include &lt;iostream&gt;
using namespace std;
class Time {
public:
	Time() {
		minute=0;
		sec=0;
	}
	Time(int m,int s):minute(m),sec(s) {}
	Time operator++() { //前置++的重载成员函数
		if(++sec&gt;=60) {
			sec-=60;
			++minute;
		}
		return *this;//return 【1】______; 
	}
	Time operator++(int) { //后置++的重载成员函数Time【2】______
		Time temp(*this);
		sec++;
		if(sec++&gt;=60 ) {//	if(【3】______ )
		
			sec-=60;
			++minute;
		}
		return temp;//return 【4】______;
	}
	void display() {
		cout&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;sec&lt;&lt;endl;
	}
private:
	int minute;
	int sec;
};
int main() {
	Time time1(34,0), time2(35,0);
	for (int i=0; i&lt;61; i++) {
		++time1;
		time1.display();
	}
	for (int j=0; j&lt;61; j++) {
		time2++;
		time2.display();
	}
	return 0;
}
Test37定义一个国家基类Country，包含国名、首都、人口等属性，派生出省类Province，增加省会城市、人口数量属性。
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
/*【1】*/class Country {
public:
	/*【2】*/Country(string nam,string c,int cp=0) {     //初始化构造函数的定义
		name=nam;
		capital=c;
		country_population=cp;
	}
protected:
	string name;
	string capital;
	long int country_population;
};
class Province:public Country {
public:
	//派生类构造函数的定义
	Province(string nam,string c,long int cp,string pc,long int pp):/*【3】*/Country(nam,c,cp){
		Province_capital=pc;
		Province_population=pp;
	};
	void show() {
		cout&lt;&lt;&quot;name:&quot;&lt;&lt;name&lt;&lt;endl;
		cout&lt;&lt;&quot;capital:&quot;&lt;&lt;capital&lt;&lt;endl;
		cout&lt;&lt;&quot;country_population:&quot;&lt;&lt;country_population&lt;&lt;endl;
		cout&lt;&lt;&quot;Province_capital:&quot;&lt;&lt;Province_capital&lt;&lt;endl;
		cout&lt;&lt;&quot;Province_population:&quot;&lt;&lt;Province_population&lt;&lt;endl;
	}
private:
	string Province_capital;
	long int Province_population;
};
int main() {
	//对象定义
	/*【4】*Province prov1(&quot;China&quot;,&quot;Beijing&quot;,1300000000,&quot;Nanchang&quot;,45000000);
	prov1.show();
	return 0;
}
Test38定义一个车基类Vehicle，含私有成员speed，weight。派生出自行车类Bicycle，增加high成员；汽车类Car，增加seatnum（座位数）成员。从bicycle和car中派生出摩托车类Motocycle。
#include&lt;iostream&gt;
using namespace std;
class Vehicle {
public:
	Vehicle(float sp,float w) {  //构造函数的定义
		speed=sp;
		weight=w;
	}
	void display() {
		cout&lt;&lt;&quot;speed:&quot;&lt;&lt;speed&lt;&lt;&quot; weight&quot;&lt;&lt;weight&lt;&lt;endl;
	}
private:
	float speed;
	float weight;
};
class Bicycle: virtual public Vehicle {  //声明Vehicle为虚基类
public:
	Bicycle(float sp,float w,float h):Vehicle(sp,w) {  //构造函数的定义
		high = h;
	}
protected:
	float high;
};
class Car:virtual public Vehicle {
public:
	Car(float sp,float w,int num):Vehicle(sp,w) {  //构造函数的定义
		seatnum = num;
	}
protected:
	int seatnum;
};
class Motorcycle: public Bicycle, public Car {
public:
	Motorcycle(float sp,float w,float h,int num):
			Vehicle(sp,w),Bicycle(sp,w,h),Car(sp,w,num) {}  //成员初始化
	void display() {
		Vehicle::display();
		cout&lt;&lt;&quot; high:&quot;&lt;&lt;high&lt;&lt;&quot; seatnum:&quot;&lt;&lt;seatnum&lt;&lt;endl;
	}
};
int main() {
	Motorcycle m(120,120,120,1);  //对象定义
	m.display();
	return 0;
}
Test39声明一个哺乳动物Mammal类，再由此派生出狗Dog类，二者都定义Speak（）成员函数，基类中定义为虚函数。声明一个Dog类的对象，调用Speak（）函数，观察运行结果
#include &lt;iostream&gt;
class Mammal {
public:
	Mammal():itsAge(1) {
		cout &lt;&lt; &quot;Mammal constructor&quot;&lt;&lt;endl;
	}
	~Mammal() {  //析构函数的定义
		cout &lt;&lt; &quot;Mammal destructor&quot;&lt;&lt;endl;
	}
	virtual void Speak() const {  //虚函数Speak()的定义
		cout &lt;&lt; &quot;Mammal speak!&quot;&lt;&lt;endl;
	}
private:
	int itsAge;
};
class Dog : public Mammal {
public:
	Dog() {
		cout &lt;&lt; &quot;Dog Constructor&quot; &lt;&lt;endl;
	}
	~Dog() {
		cout &lt;&lt; &quot;Dog destructor&quot; &lt;&lt;endl;
	}
	void Speak() const {
		cout &lt;&lt; &quot;Woof!&quot;&lt;&lt;endl;
	}
};
int main() {
	Mammal *pDog = new Dog;
	pDog-&gt;Speak();  //使用pDog调用Speak()函数
	delete pDog;  //释放对象
	return 0;
}
Test40定义一个抽象类Cshape，包含纯虚数Area（用来计算面积）。然后派生出三角形Ctriangle类、矩形Crect类、圆Ccircle类，分别求其面积。最后定义一个CArea类，计算着几个形状的面积之和，各形状的数据通过CArea类构造函数或成员函数来设置。
#include&lt;iostream&gt;
using namespace std;
class Cshape {
public:
	virtual float Area() const=0;  //纯虚函数Area()的声明 【1】______ float Area()【2】______;
};
class CTriangle: public Cshape {
	int vect;
public:
	CTriangle(int v):vect(v) {}
	float Area() {
		return vect*1.732/4;
	}

};
class CRect: public Cshape {
	int length,height;
public:
	CRect(int l,int h):length(l),height(h) {}
	float Area() {
		return length*height;
	}

};
class CCircle: public Cshape {
	int radius;
public:
	CCircle(int r):radius(r) {}
	float Area() {
		return 3.14*radius*radius;
	}
};
class Area {
	CTriangle t;
	CRect r;
	CCircle c;
public:
	Area(int v,int l,int h,int r):t(v),r(l,h),c(r)  {}  //子对象初始化列表   不会 
	float sum() {
		return t.Area()+r.Area()+c.Area();
	}
};
int main() {
	Area a(10,20,30,5);  //对象定义 4】______ a(10,20,30,5); 
	cout&lt;&lt;a.sum()&lt;&lt;endl;
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[40道c++程序填空题]]></title>
        <id>https://guohaomeng.github.io/post/40-dao-ccheng-xu-tian-kong-ti</id>
        <link href="https://guohaomeng.github.io/post/40-dao-ccheng-xu-tian-kong-ti">
        </link>
        <updated>2019-06-08T12:19:16.000Z</updated>
        <summary type="html"><![CDATA[<p>还是用图片形式比较好...</p>
]]></summary>
        <content type="html"><![CDATA[<p>还是用图片形式比较好...</p>
<!-- more -->
<p>传送门1：<a href="../../../otherfiles/c++.html">网页版</a></p>
<p>传送门2：<a href="../../../otherfiles/C++%E7%A8%8B%E5%BA%8F%E9%A2%98%E5%A4%8D%E4%B9%A0.docx">word版</a></p>
<p>图片版：</p>
<p><img src="https://guohaomeng.github.io/post-images/1559996503170.jpeg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1559996509283.jpeg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1559996518471.jpeg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1559996524513.jpeg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1559996546642.jpeg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1559996569468.jpeg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1559996599087.jpeg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1559996605702.jpeg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1559996612458.jpeg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1559996626102.jpeg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1559996634623.jpeg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1559996642788.jpeg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1559996650175.jpeg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1559996657022.jpeg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1559996664971.jpeg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1559996672705.jpeg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1559996679954.jpeg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1559996686631.jpeg" alt=""><br>
<img src="https://guohaomeng.github.io/post-images/1559996692690.jpeg" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[简单的代码，不简单的特效]]></title>
        <id>https://guohaomeng.github.io/post/jian-dan-de-dai-ma-bu-jian-dan-de-te-xiao</id>
        <link href="https://guohaomeng.github.io/post/jian-dan-de-dai-ma-bu-jian-dan-de-te-xiao">
        </link>
        <updated>2019-06-04T13:44:35.000Z</updated>
        <summary type="html"><![CDATA[<p>150行不到的代码量......</p>
]]></summary>
        <content type="html"><![CDATA[<p>150行不到的代码量......</p>
<!-- more -->
<h3 id="不废话上代码">不废话，上代码</h3>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;

&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;粒子海洋特效&lt;/title&gt;
&lt;/head&gt;
&lt;style&gt;
  canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
&lt;/style&gt;

&lt;body&gt;
&lt;/body&gt;
&lt;script&gt;
  // Init Context 粒子海洋
  let c = document.createElement('canvas').getContext('2d')
  let postctx = document.body.appendChild(document.createElement('canvas')).getContext('2d')
  let canvas = c.canvas
  let vertices = []

  // Effect Properties
  let vertexCount = 7000
  let vertexSize = 3
  let oceanWidth = 204
  let oceanHeight = -80
  let gridSize = 32;
  let waveSize = 16;
  let perspective = 100;

  // Common variables
  let depth = (vertexCount / oceanWidth * gridSize)
  let frame = 0
  let { sin, cos, tan, PI } = Math

  // Render loop
  let loop = () =&gt; {
    let rad = sin(frame / 100) * PI / 20
    let rad2 = sin(frame / 50) * PI / 10
    frame++
    if (postctx.canvas.width !== postctx.canvas.offsetWidth || postctx.canvas.height !== postctx.canvas.offsetHeight) {
      postctx.canvas.width = canvas.width = postctx.canvas.offsetWidth
      postctx.canvas.height = canvas.height = postctx.canvas.offsetHeight
    }


    c.fillStyle = `hsl(200deg, 100%, 2%)`
    c.fillRect(0, 0, canvas.width, canvas.height)
    c.save()
    c.translate(canvas.width / 2, canvas.height / 2)

    c.beginPath()
    vertices.forEach((vertex, i) =&gt; {
      let ni = i + oceanWidth
      let x = vertex[0] - frame % (gridSize * 2)
      let z = vertex[2] - frame * 2 % gridSize + (i % 2 === 0 ? gridSize / 2 : 0)
      let wave = (cos(frame / 45 + x / 50) - sin(frame / 20 + z / 50) + sin(frame / 30 + z * x / 10000))
      let y = vertex[1] + wave * waveSize
      let a = Math.max(0, 1 - (Math.sqrt(x ** 2 + z ** 2)) / depth)
      let tx, ty, tz

      y -= oceanHeight

      // Transformation variables
      tx = x
      ty = y
      tz = z

      // Rotation Y
      tx = x * cos(rad) + z * sin(rad)
      tz = -x * sin(rad) + z * cos(rad)

      x = tx
      y = ty
      z = tz

      // Rotation Z
      tx = x * cos(rad) - y * sin(rad)
      ty = x * sin(rad) + y * cos(rad)

      x = tx;
      y = ty;
      z = tz;

      // Rotation X

      ty = y * cos(rad2) - z * sin(rad2)
      tz = y * sin(rad2) + z * cos(rad2)

      x = tx;
      y = ty;
      z = tz;

      x /= z / perspective
      y /= z / perspective



      if (a &lt; 0.01) return
      if (z &lt; 0) return


      c.globalAlpha = a
      c.fillStyle = `hsl(${180 + wave * 20}deg, 100%, 50%)`
      c.fillRect(x - a * vertexSize / 2, y - a * vertexSize / 2, a * vertexSize, a * vertexSize)
      c.globalAlpha = 1
    })
    c.restore()

    // Post-processing
    postctx.drawImage(canvas, 0, 0)

    postctx.globalCompositeOperation = &quot;screen&quot;
    postctx.filter = 'blur(16px)'
    postctx.drawImage(canvas, 0, 0)
    postctx.filter = 'blur(0)'
    postctx.globalCompositeOperation = &quot;source-over&quot;

    requestAnimationFrame(loop)
  }

  // Generating dots
  for (let i = 0; i &lt; vertexCount; i++) {
    let x = i % oceanWidth
    let y = 0
    let z = i / oceanWidth &gt;&gt; 0
    let offset = oceanWidth / 2
    vertices.push([(-offset + x) * gridSize, y * gridSize, z * gridSize])
  }

  loop()
&lt;/script&gt;

&lt;/html&gt;
</code></pre>
<p>惊了Σ(っ °Д °;)っ<br>
<img src="https://guohaomeng.github.io/post-images/1559656298568.png" alt=""><br>
传送门：<a href="../../../otherfiles/index1.html">粒子海洋特效</a><br>
看一送一：<a href="../../../otherfiles/clock.html">时钟</a><br>
ps:注意这个有些占用CPU。。。还有手机端不一定能正常显示</p>
]]></content>
    </entry>
</feed>